#include "fft.h"

// ---------------------------------------------------------------------------
// Таблицы тайдл-факторов (Q15 = * 32767)
// cos128[k] = cos(2*pi*k/128) * 32767,  k = 0..63
// sin128[k] = sin(2*pi*k/128) * 32767,  k = 0..63
//
// Тайдл-фактор для ступени s, позиции j в группе:
//   step = 64 / half  (half = 2^(s-1))
//   wr   =  cos128[j * step]
//   wi   = -sin128[j * step]   (W_N^k = e^(-j*2pi*k/N))
// ---------------------------------------------------------------------------

static const int16_t cos128[64] = {
   32767,  32728,  32609,  32412,  32137,  31785,  31356,  30852,
   30273,  29621,  28898,  28105,  27245,  26319,  25329,  24279,
   23170,  22005,  20787,  19519,  18204,  16846,  15446,  14010,
   12539,  11039,   9512,   7962,   6393,   4808,   3212,   1608,
       0,  -1608,  -3212,  -4808,  -6393,  -7962,  -9512, -11039,
  -12539, -14010, -15446, -16846, -18204, -19519, -20787, -22005,
  -23170, -24279, -25329, -26319, -27245, -28105, -28898, -29621,
  -30273, -30852, -31356, -31785, -32137, -32412, -32609, -32728,
};

static const int16_t sin128[64] = {
       0,   1608,   3212,   4808,   6393,   7962,   9512,  11039,
   12539,  14010,  15446,  16846,  18204,  19519,  20787,  22005,
   23170,  24279,  25329,  26319,  27245,  28105,  28898,  29621,
   30273,  30852,  31356,  31785,  32137,  32412,  32609,  32728,
   32767,  32728,  32609,  32412,  32137,  31785,  31356,  30852,
   30273,  29621,  28898,  28105,  27245,  26319,  25329,  24279,
   23170,  22005,  20787,  19519,  18204,  16846,  15446,  14010,
   12539,  11039,   9512,   7962,   6393,   4808,   3212,   1608,
};

// ---------------------------------------------------------------------------
// Таблица бит-реверса для N=128 (7-битная перестановка)
// ---------------------------------------------------------------------------
static const uint8_t bitrev128[128] = {
     0,  64,  32,  96,  16,  80,  48, 112,   8,  72,  40, 104,  24,  88,  56, 120,
     4,  68,  36, 100,  20,  84,  52, 116,  12,  76,  44, 108,  28,  92,  60, 124,
     2,  66,  34,  98,  18,  82,  50, 114,  10,  74,  42, 106,  26,  90,  58, 122,
     6,  70,  38, 102,  22,  86,  54, 118,  14,  78,  46, 110,  30,  94,  62, 126,
     1,  65,  33,  97,  17,  81,  49, 113,   9,  73,  41, 105,  25,  89,  57, 121,
     5,  69,  37, 101,  21,  85,  53, 117,  13,  77,  45, 109,  29,  93,  61, 125,
     3,  67,  35,  99,  19,  83,  51, 115,  11,  75,  43, 107,  27,  91,  59, 123,
     7,  71,  39, 103,  23,  87,  55, 119,  15,  79,  47, 111,  31,  95,  63, 127,
};

// ---------------------------------------------------------------------------
// FFT_128 — radix-2 DIT FFT, 7 ступеней.
//
// Масштабирование: каждый баттерфляй делит оба выхода на 2 (>> 1).
// Это предотвращает переполнение int16_t на любой ступени.
// Суммарный масштаб: 1/2^7 = 1/128.
//
// Баттерфляй на ступени s:
//   tr  = (wr*re[i2] - wi*im[i2]) >> 15   (Q15 умножение)
//   ti  = (wr*im[i2] + wi*re[i2]) >> 15
//   re[i2] = (re[i1] - tr) >> 1
//   im[i2] = (im[i1] - ti) >> 1
//   re[i1] = (re[i1] + tr) >> 1
//   im[i1] = (im[i1] + ti) >> 1
// ---------------------------------------------------------------------------
void FFT_128(int16_t *re, int16_t *im) {
  // --- Бит-реверсивная перестановка ---
  for (int i = 0; i < 128; i++) {
    int j = bitrev128[i];
    if (j > i) {
      int16_t t;
      t = re[i]; re[i] = re[j]; re[j] = t;
      t = im[i]; im[i] = im[j]; im[j] = t;
    }
  }

  // --- 7 ступеней FFT ---
  for (int s = 1; s <= 7; s++) {
    int len  = 1 << s;          // длина группы: 2, 4, 8, ..., 128
    int half = len >> 1;        // половина группы: 1, 2, 4, ..., 64
    int step = 64 / half;       // шаг по таблице тайдл-факторов: 64,32,...,1

    for (int k = 0; k < 128; k += len) {
      for (int j = 0; j < half; j++) {
        int ti = j * step;              // индекс в cos128/sin128
        int32_t wr =  (int32_t)cos128[ti];
        int32_t wi = -(int32_t)sin128[ti];

        int i1 = k + j;
        int i2 = k + j + half;

        // Q15 умножение: тайдл * правый операнд
        int16_t tr = (int16_t)((wr * re[i2] - wi * im[i2]) >> 15);
        int16_t ti2 = (int16_t)((wr * im[i2] + wi * re[i2]) >> 15);

        // Баттерфляй с масштабированием /2
        re[i2] = (re[i1] - tr) >> 1;
        im[i2] = (im[i1] - ti2) >> 1;
        re[i1] = (re[i1] + tr) >> 1;
        im[i1] = (im[i1] + ti2) >> 1;
      }
    }
  }
}

// ---------------------------------------------------------------------------
// FFT_Magnitude — быстрое приближение к |X| без деления и корня.
//
// Используется формула Эла Уильяма:
//   mag ≈ 0.96*max + 0.40*min   (максимальная погрешность ~3.5%)
// В целых числах (>>5 вместо *0.96, >>2 вместо *0.25 — чуть огрублено):
//   mag = max + (min >> 2)    (≈ |x| + 0.25|y|, погрешность <12%, зато быстро)
//
// Для осциллографа это вполне достаточно.
// ---------------------------------------------------------------------------
void FFT_Magnitude(const int16_t *re, const int16_t *im,
                   uint16_t *mag, int count) {
  for (int k = 0; k < count; k++) {
    int32_t r = re[k] < 0 ? -re[k] : re[k];
    int32_t i = im[k] < 0 ? -im[k] : im[k];
    int32_t mx = r > i ? r : i;
    int32_t mn = r < i ? r : i;
    // 0.96*max + 0.40*min ≈ max - max/32 + min*13/32 (всё целочисленно)
    int32_t m = mx - (mx >> 5) + (mn * 13 >> 5);
    mag[k] = m > 65535 ? 65535 : (uint16_t)m;
  }
}
