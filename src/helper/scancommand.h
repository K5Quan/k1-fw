#ifndef SCANCOMMAND_H
#define SCANCOMMAND_H

#include <stdbool.h>
#include <stdint.h>

/**
 * @file scan_cmd.h
 * @brief Библиотека для потокового выполнения команд сканирования
 *
 * Формат файла:
 * - Заголовок SCMD_Header (16 байт)
 * - Массив команд SCMD_Command (по 16 байт каждая)
 *
 * Использование:
 * 1. Создать файл команд на ПК (утилитой scan_gen)
 * 2. Загрузить в LittleFS (/scans/*.bin)
 * 3. В коде: SCMD_Init() → цикл SCMD_ExecuteCurrent() → SCMD_Advance()
 * 4. В любой момент можно SCMD_Rewind() или SCMD_Close()
 */

// ============================================================================
// ТИПЫ КОМАНД
// ============================================================================

/**
 * @brief Типы команд сканирования
 */
typedef enum {
  SCMD_CHANNEL = 0, ///< Сканирование одного канала
  SCMD_RANGE = 1, ///< Сканирование диапазона частот
  SCMD_JUMP = 2, ///< Безусловный переход на другую команду
  SCMD_CJUMP = 3, ///< Условный переход (если обнаружен сигнал)
  SCMD_PAUSE = 4,    ///< Пауза выполнения
  SCMD_BLACKOUT = 5, ///< Временное добавление частоты в черный список
  SCMD_MARKER = 6, ///< Метка для переходов (не выполняет действий)
  SCMD_CALL = 7,   ///< Вызов подпрограммы
  SCMD_RETURN = 8, ///< Возврат из подпрограммы
  SCMD_SETPRIO = 9, ///< Установка минимального приоритета
  SCMD_SETMODE = 10, ///< Установка режима сканирования
  SCMD_SETPOWER = 11, ///< Установка мощности передатчика
  SCMD_SETGAIN = 12, ///< Установка усиления приемника
  SCMD_RECORD = 13,  ///< Начать запись RAW данных
  SCMD_STOPREC = 14, ///< Остановить запись
  SCMD_TRIGGER = 15, ///< Отправить триггерный сигнал
} SCMD_Type;

// ============================================================================
// ФЛАГИ КОМАНД
// ============================================================================

#define SCMD_FLAG_AUTO_WHITELIST                                               \
  (1 << 0) ///< Автоматически добавить в белый список при обнаружении
#define SCMD_FLAG_RECORD_RAW                                                   \
  (1 << 1) ///< Записывать RAW данные во время сканирования
#define SCMD_FLAG_IGNORE_BLACK                                                 \
  (1 << 2) ///< Игнорировать черный список для этой частоты
#define SCMD_FLAG_HIGH_SENS                                                    \
  (1 << 3) ///< Высокая чувствительность (больше энергии)
#define SCMD_FLAG_LOW_POWER (1 << 4) ///< Режим пониженного энергопотребления
#define SCMD_FLAG_LOOP_UNTIL (1 << 5) ///< Цикл до выполнения условия
#define SCMD_FLAG_BURST (1 << 6) ///< Пакетный режим (быстрое сканирование)
#define SCMD_FLAG_DEEP (1 << 7) ///< Глубокий анализ (длительное сканирование)

// ============================================================================
// СТРУКТУРЫ ДАННЫХ
// ============================================================================

#pragma pack(push, 1)

/**
 * @brief Команда сканирования (16 байт)
 *
 * Поля команды:
 * - type:       Тип команды (SCMD_Type)
 * - priority:   Приоритет 0-255 (255 - высший)
 * - flags:      Битовая маска флагов (SCMD_FLAG_*)
 * - loop_count: Количество повторов (0 = нет цикла)
 * - dwell_ms:   Время сканирования на точке/частоте (мс)
 * - timeout_ms: Таймаут ожидания сигнала (мс)
 * - goto_offset: Смещение для перехода (в командах от начала)
 * - start:      Начальная частота или параметр 1
 * - end:        Конечная частота или параметр 2
 */
typedef struct {
  uint8_t type;         ///< Тип команды
  uint8_t priority;     ///< Приоритет выполнения
  uint8_t flags;        ///< Флаги команды
  uint8_t loop_count;   ///< Счетчик циклов
  uint16_t dwell_ms;    ///< Время на точке (мс)
  uint16_t timeout_ms;  ///< Таймаут прослушивания (мс)
  uint16_t goto_offset; ///< Смещение перехода
  uint32_t start; ///< Параметр 1 (частота/значение)
  uint32_t end;   ///< Параметр 2 (частота/значение)
} SCMD_Command;

/**
 * @brief Заголовок файла команд (16 байт)
 */
typedef struct {
  uint32_t magic;     ///< Магическое число 'SCMD' (0x53434D44)
  uint16_t version;   ///< Версия формата (1)
  uint16_t cmd_count; ///< Количество команд в файле
  uint32_t entry_point; ///< Точка входа (смещение первой команды)
  uint32_t crc32; ///< Контрольная сумма содержимого
} SCMD_Header;

/**
 * @brief Контекст выполнения сканера
 *
 * Хранит состояние интерпретатора. Всегда в RAM.
 * Размер: 16 + 16 + 4 + 2 + 8 + 1 + 16 + 1 + 1 = ~65 байт
 */
typedef struct {
  SCMD_Command current; ///< Текущая выполняемая команда
  SCMD_Command next; ///< Следующая команда (предзагрузка)
  uint32_t file_pos; ///< Текущая позиция в файле (байты)
  uint16_t cmd_index; ///< Индекс текущей команды (0-based)
  uint8_t loop_stack[8]; ///< Стек счетчиков циклов
  uint8_t loop_ptr;      ///< Указатель стека циклов (0-7)
  uint32_t call_stack[4]; ///< Стек возвратов (позиции в файле)
  uint8_t call_ptr; ///< Указатель стека вызовов (0-3)
  bool has_next; ///< Флаг наличия следующей команды
} SCMD_Context;

#pragma pack(pop)

// ============================================================================
// МАКРОСЫ И КОНСТАНТЫ
// ============================================================================

/// Магическое число файла (ASCII "SCMD")
#define SCMD_MAGIC 0x53434D44

/// Текущая версия формата
#define SCMD_VERSION 1

/// Максимальное количество команд в файле
#define SCMD_MAX_COMMANDS 1024

/// Размер команды в байтах
#define SCMD_CMD_SIZE sizeof(SCMD_Command)

/// Размер заголовка в байтах
#define SCMD_HDR_SIZE sizeof(SCMD_Header)

// ============================================================================
// ПУБЛИЧНЫЕ ФУНКЦИИ
// ============================================================================

#ifdef __cplusplus
extern "C" {
#endif

/**
 * @brief Инициализация сканера из файла
 *
 * @param filename Путь к файлу команд в LittleFS
 * @return true - успех, false - ошибка (файл не найден/неверный формат)
 *
 * @note Открывает файл, читает заголовок, загружает первую команду.
 *       Требует ~320 байт RAM (256 буфер LFS + 65 контекст).
 */
bool SCMD_Init(const char *filename);

/**
 * @brief Переход к следующей команде
 *
 * @return true - есть следующая команда, false - конец файла
 *
 * @note Автоматически обрабатывает переходы (JUMP/CJUMP).
 *       Если достигнут конец файла, нужно вызвать SCMD_Rewind().
 */
bool SCMD_Advance(void);

/**
 * @brief Выполнение текущей команды
 *
 * Вызывает соответствующий обработчик команды.
 * Зависит от внешних функций сканирования.
 */
void SCMD_ExecuteCurrent(void);

/**
 * @brief Проверка необходимости пропуска команды по приоритету
 *
 * @return true - команду можно пропустить, false - нужно выполнить
 *
 * @note Использует внешнюю функцию GetCurrentMinPriority().
 */
bool SCMD_ShouldSkip(void);

/**
 * @brief Получить указатель на текущую команду
 *
 * @return Указатель на текущую команду (или NULL если нет)
 */
SCMD_Command *SCMD_GetCurrent(void);

/**
 * @brief Получить указатель на следующую команду
 *
 * @return Указатель на следующую команду (или NULL если нет)
 */
SCMD_Command *SCMD_GetNext(void);

/**
 * @brief Проверить наличие следующей команды
 *
 * @return true - есть следующая команда, false - конец файла
 */
bool SCMD_HasNext(void);

/**
 * @brief Перемотка к началу файла
 *
 * Сбрасывает контекст выполнения и начинает с первой команды.
 */
void SCMD_Rewind(void);

/**
 * @brief Закрытие файла и очистка контекста
 */
void SCMD_Close(void);

/**
 * @brief Получить индекс текущей команды
 *
 * @return Индекс команды (0-based) или 0xFFFF если файл не открыт
 */
uint16_t SCMD_GetCurrentIndex(void);

/**
 * @brief Перейти к команде по индексу
 *
 * @param index Индекс команды (0-based)
 * @return true - успех, false - неверный индекс
 */
bool SCMD_GotoIndex(uint16_t index);

/**
 * @brief Установить точку входа (для перезапуска с середины)
 *
 * @param offset Смещение команды от начала (в командах, не байтах)
 */
void SCMD_SetEntryPoint(uint16_t offset);

void SCMD_CreateExampleScan(void);

#ifdef __cplusplus
}
#endif

#endif // !SCANCOMMAND_H
